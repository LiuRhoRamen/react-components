{
    "Content": {
        "path": "Modal/Content.md",
        "name": "Content",
        "info": "### 说明\n\n弹窗内容容器组件，为了方便组合，没有将间距、滚动等内置，而是拆分为自组件\n\n### 演示\n\n#### 演示\n\n```js {\"codepath\": \"content.jsx\"}\n```\n"
    },
    "Modal": {
        "path": "Modal/Modal.md",
        "name": "Modal",
        "info": "### 说明\n\n-   弹窗组件，纯受控组件，显示隐藏通过 visible 控制\n-   提供 jsx 使用和命令式调用\n-   <b style=\"color: red;\">如果想要命令式调用需要注意确保理解命令式调用的风险再去使用</b>\n\n### <b style=\"color:red;\">关于命令式调用弹窗的风险告知</b>\n\n命令式调用弹窗虽然看似简单易用但却存在一些不可避免的风险，而且不易追踪和排查。\n\n实现：命令式主要调用通过创建一个单独的 React 渲染实例来实现，所以存在以下已知问题（是否存在其它风险还不知道）：\n\n1.  <b style=\"color:red;\">会导致上下文丢失</b>\n\n    由于和主实例无关联，会导致 Context 无法获取等各种问题，组件只能解决一些全局的 Context 的处理（并且伴随着一定风险，页面存在多实例可能会出现错乱的情况），而其它项目中的 Context 都会丢失，需要调用者自己处理使用 Context 包裹弹窗等。\n    <b style=\"color:red;\">并且这种问题不易排查，风险极大。</b>\n\n2.  <b style=\"color:red;\">生命周期脱离</b>\n\n    同样由于命令式调用，会导致 Modal 的生命周期脱离，在对应页面生命周期变动时无法同步到，需要自行处理销毁、更新等操作。否则会出现如未关闭弹窗时切换页面，弹窗依旧存在等问题。\n    <b style=\"color:red;\">同样这种问题不易排查，风险极大。</b>\n\n替换方案：\n\n通过声明式弹窗可以非常简单的替换掉命令式弹窗，可以看到<b style=\"color:red;\">代码量没有任何的增加，但是却可以规避上述的问题</b>，并且下述的命令弹窗还没处理声明周期的问题，卸载时没有销毁弹窗（可点开弹窗点浏览器后退对比试试），如果加上常规处理，<b style=\"color:red;\">命令式的代码量会更多且风险更高</b>：\n\n```js\nclass DetailModal extends React.Component {\n    render() {\n        return (\n            <Modal\n                visible\n                footer={\n                    <div>\n                        <Button styleType=\"primary\" onClick={this.props.onClose}>\n                            确定\n                        </Button>\n                    </div>\n                }\n                onClose={this.props.onClose}\n            >\n                <Modal.Content>This is the detail for {this.props.detail.title}</Modal.Content>\n            </Modal>\n        );\n    }\n}\nDetailModal.propTypes = {\n    onClose: PropTypes.func.isRequired,\n    detail: PropTypes.object.isRequired\n};\n\nconst dataSource = new Array(100).fill(null).map((item, i) => ({\n    key: i,\n    title: `item ${i}`\n}));\nconst columns = [\n    {\n        title: 'title',\n        key: 'title',\n        dataIndex: 'title'\n    }\n];\n\nclass IDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n        this.columns = [\n            ...columns,\n            {\n                title: 'action',\n                key: 'action',\n                render: item => {\n                    return <ActionList actionList={[{ label: 'detail', onClick: () => this.showDetail(item) }]} />;\n                }\n            }\n        ];\n    }\n    showDetail(item) {\n        this.modal = Modal.openModal(<DetailModal detail={item} onClose={() => this.closeDetail()} />);\n    }\n    closeDetail() {\n        this.modal.destroy();\n    }\n    onEnd(result) {\n        if (!this.modal) return;\n        console.log(result);\n        this.modal.destroy();\n    }\n    render() {\n        return (\n            <div>\n                <Table dataSource={dataSource} columns={this.columns} />\n            </div>\n        );\n    }\n}\n\nclass SDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n        this.columns = [\n            ...columns,\n            {\n                title: 'action',\n                key: 'action',\n                render: item => {\n                    return <ActionList actionList={[{ label: 'detail', onClick: () => this.showDetail(item) }]} />;\n                }\n            }\n        ];\n    }\n    showDetail(item) {\n        this.setState({ detailModal: item });\n    }\n    closeDetail() {\n        this.setState({ detailModal: null });\n    }\n    render() {\n        return (\n            <div>\n                <Table dataSource={dataSource} columns={this.columns} />\n                {this.state.detailModal && (\n                    <DetailModal detail={this.state.detailModal} onClose={() => this.closeDetail()} />\n                )}\n            </div>\n        );\n    }\n}\n\n<div>\n    <h2 style={{ color: 'red' }}>命令式</h2>\n    <IDemo />\n    <h2 style={{ color: 'green' }}>声明式</h2>\n    <SDemo />\n</div>;\n```\n\n后续：后续或许会通过 hooks 来处理一些命令式的问题，<b style=\"color:red;\">但是使用并不会更方便</b>，处理后使用上其实依旧只能规避一些常规问题，如常规声明周期等问题，项目内部的上下文问题依旧会比较麻烦，<b style=\"color:red;\">存在隐藏的风险而不易排查</b>。\n\n```js {\"static\": true}\nconst Demo = () => {\n    const modal = useModal();\n    const showDetail = () => modal.openModal(<DetailModal detail={item} onClose={() => this.closeDetail()} />);\n};\n```\n\n### 演示\n\n#### 演示\n\n```js {\"codepath\": \"modal.jsx\"}\n```\n\n#### method - 简单的命令式打开弹窗 <b style=\"color:red;\">慎用</b>\n\n```js {\"codepath\": \"method.jsx\"}\n```\n\n#### openModal - 命令式调用打开整个弹窗 <b style=\"color:red;\">慎用</b>\n\n```js {\"codepath\": \"openModal.jsx\"}\n```\n\n#### title/footer - 自定义 title/footer 内容\n\n```js {\"codepath\": \"titleAndFooter.jsx\"}\n```\n\n#### size - 预设尺寸\n\n```js {\"codepath\": \"size.jsx\"}\n```\n\n#### closable - 关闭按钮\n\n```js {\"codepath\": \"closable.jsx\"}\n```\n\n#### mask - 是否有遮罩层\n\n```js {\"codepath\": \"mask.jsx\"}\n```\n\n#### buttonProps - 自定义按钮属性\n\n```js {\"codepath\": \"buttonProps.jsx\"}\n```\n\n#### maskClosable - 是否可通过点击遮罩层关闭\n\n```js {\"codepath\": \"maskClosable.jsx\"}\n```\n\n#### keyboard - 是否可通过键盘关闭\n\n```js {\"codepath\": \"keyboard.jsx\"}\n```\n\n#### destroyOnClose - 关闭后是否直接销毁\n\n```js {\"codepath\": \"destroyOnClose.jsx\"}\n```\n\n#### notice - 弹窗中的提示\n\n```js {\"codepath\": \"notice.jsx\"}\n```\n\n#### 自定义 className\n\n```js {\"codepath\": \"customClassName.jsx\"}\n```\n\n#### 自定义样式\n\n```js {\"codepath\": \"customStyle.jsx\"}\n```\n\n#### popupContainer - 弹出层容器\n\n```js {\"codepath\": \"popupContainer.jsx\"}\n```\n"
    }
}
